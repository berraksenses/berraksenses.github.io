<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <title>My first three.js app</title>
</head>
<body>

    <canvas id="gl-canvas" width="512" height="512">
        Oops ... your browsesdfgdfsgdsfgsdfghsdfhdfghdfgr doesn't support the HTML5 canvas element
    </canvas>

    <script src="/three.js-master/build/three.js"></script>
    <script>

        var dogLegFlag = false

        var leftDogArm;
        var rightDogArm;
        var leftDogLeg;
        var rightDogLeg;
        var dogGroup;
        var headGroup;
        var time = 0;
        var legForwardFlag = true;

        var scene = new THREE.Scene();
        var camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.2, 1000);

        var humanGroup = new THREE.Object3D;
        var humanUpperGroup = new THREE.Object3D;
        var renderer = new THREE.WebGLRenderer();
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.body.appendChild(renderer.domElement);



        camera.up.set(0, 1, 0);
        camera.lookAt(0, 0, 0);

        createHumanoid();
        createDoggo();

        dogGroup.rotation.y= 50;

        function legGoingForward() {

            

            leftDogArm.rotation.z -= Math.PI / 30
            rightDogArm.rotation.z += Math.PI / 180
            //leftDogArm.rotation.z += Math.PI / 30
            //rightDogArm.rotation.z -= Math.PI / 180
            //setTimeout(legGoingForward, 20000);
            
        }




        var mainLoop = () => {

            if (time <= 20 && legForwardFlag) {

                //leftDogArm.rotation.z -= Math.PI / 180;
                //rightDogArm.rotation.z += Math.PI / 180; 
                rightDogLeg.rotation.z -= (Math.PI / 180 * 0.90);
                //leftDogLeg.rotation.z += Math.PI / 180;

                rightDogLeg.children[0].rotation.z += (Math.PI / 180 * 0.90);
                //leftDogLeg.children[0].rotation.z -= Math.PI / 100;

                leftDogArm.children[0].rotation.z += Math.PI / 280;
                //rightDogArm.children[0].rotation.z -= Math.PI / 100;



                time += 1;

               (time == 20) ? (legForwardFlag = false) : time = time;
            }
            else {
                //alert(time);
                //leftDogArm.rotation.z += Math.PI /180;
                //rightDogArm.rotation.z -= Math.PI / 180;

                rightDogLeg.rotation.z += (Math.PI / 180 * 0.90);
                //leftDogLeg.rotation.z -= Math.PI / 180;

                rightDogLeg.children[0].rotation.z -= (Math.PI / 180 * 0.90)  ;
                //leftDogLeg.children[0].rotation.z += Math.PI / 100;

                leftDogArm.children[0].rotation.z -= Math.PI / 280;
                //rightDogArm.children[0].rotation.z += Math.PI / 100;


                time -= 1;
                console.log(rightDogLeg.children[0]);
                (time == 0) ? legForwardFlag = true : time = time;

            }

               requestAnimationFrame(mainLoop)

               renderer.render(scene, camera)


        //    //humanGroup.rotation.y -= Math.PI / 180
        //    //humanGroup.rotation.z += Math.PI / 180


        }
        mainLoop();


      
        function createArm() {

            var armGroup = new THREE.Object3D;
            var armMaterial;

            var lowerArmCylinder;
            var upperArmCylinder;
            var upperArmCylinderGeometry;
            var lowerArmCylinderGeometry;

            if (dogLegFlag) {
                armMaterial = new THREE.MeshPhongMaterial({ emissive: 0xD2691E });

                upperArmCylinderGeometry = new THREE.CylinderGeometry(0.06, 0.06, 0.35, 0.005);
                upperArmCylinder = new THREE.Mesh(upperArmCylinderGeometry, armMaterial);

                lowerArmCylinderGeometry = new THREE.CylinderGeometry(0.06, 0.06, 0.35, 0.005);
                lowerArmCylinder = new THREE.Mesh(lowerArmCylinderGeometry, armMaterial);

            }

            else {
                var armMaterial2 = new THREE.MeshBasicMaterial({ color: 0xcfffff });

                armMaterial = new THREE.MeshBasicMaterial({ color: 0xD2691E });
                upperArmCylinderGeometry = new THREE.CylinderGeometry(0.06, 0.06, 0.35, 0.005);
                upperArmCylinder = new THREE.Mesh(upperArmCylinderGeometry, armMaterial);

                lowerArmCylinderGeometry = new THREE.CylinderGeometry(0.06, 0.06, 0.35, 0.005);
                lowerArmCylinder = new THREE.Mesh(lowerArmCylinderGeometry, armMaterial2);
            }

            lowerArmCylinder.position.y = -0.35;
          //  lowerArmCylinder.rotateZ(Math.PI/180*180);
            //lowerArmCylinder.position.x = 0.03;
            upperArmCylinder.add(lowerArmCylinder);
            //armGroup.add(upperArmCylinder); 
            return upperArmCylinder;

        }

        function createLegs() {

            var upperLegCylinderGeometry;
            var upperLegCylinder;

            var lowerLegCylinderGeometry;
            var lowerLegCylinder;

            var legMaterial = new THREE.MeshPhongMaterial({ emissive: 0xc11f0f });
            var legMaterial2 = new THREE.MeshBasicMaterial({ emissive: 0xc11fff });


            upperLegCylinderGeometry = new THREE.CylinderGeometry(0.07, 0.07, 0.95, 0.005);
            upperLegCylinder = new THREE.Mesh(upperLegCylinderGeometry, legMaterial);

            lowerLegCylinderGeometry = new THREE.CylinderGeometry(0.07, 0.07, 0.25, 0.005);
            lowerLegCylinder = new THREE.Mesh(lowerLegCylinderGeometry, legMaterial2);


            lowerLegCylinder.position.y = -0.6;
            upperLegCylinder.add(lowerLegCylinder);

            return upperLegCylinder;

        }



        function createHumanoid() {

            dogLegFlag = false;

            var torsoCylinderGeometry = new THREE.CylinderGeometry(0.23, 0.23, 0.95, 0.35);
            var torsoCylinderMaterial = new THREE.MeshBasicMaterial({ color: 0xcf1ff6 });

            var torsoCylinder = new THREE.Mesh(torsoCylinderGeometry, torsoCylinderMaterial);

            var neckCylinderGeometry = new THREE.CylinderGeometry(0.07, 0.07, 0.18, 0.05);
            var neckCylinderMaterial = new THREE.MeshBasicMaterial({ color: 0xcf1f1f });

            var neckCylinder = new THREE.Mesh(neckCylinderGeometry, neckCylinderMaterial);

            var torsoCylinder = new THREE.Mesh(torsoCylinderGeometry, torsoCylinderMaterial);
            torsoCylinder.position.set(0.55, 0.14, 0);
            torsoCylinder.add(neckCylinder);

            humanUpperGroup.add(torsoCylinder);


            const sphereGeometry = new THREE.SphereBufferGeometry(
                0.18, 20, 20);

            const headMaterial = new THREE.MeshPhongMaterial({ emissive: 0xFFFF00 });
            const headMesh = new THREE.Mesh(sphereGeometry, headMaterial);
            neckCylinder.add(headMesh);

            headMesh.position.y = 0.24;
            neckCylinder.position.y = 0.55;
            neckCylinder.position.x = 0;
            humanUpperGroup.position.set(0,0,-4);


            var leftArms = createArm();
            var rightArms = createArm();

            var leftLegs = createLegs();
            var rightLegs = createLegs();

            rightArms.position.x = 0.29;
            rightArms.position.y = 0.25;
            leftArms.position.x = -0.27;
            leftArms.position.y = 0.25;
            
            rightLegs.position.x = 0.45;
            rightLegs.position.y = -0.5;

            leftLegs.position.x = 0.65;
            leftLegs.position.y = -0.5;
            

            torsoCylinder.add(rightArms);
            torsoCylinder.add(leftArms);
            humanUpperGroup.add(leftLegs);
            humanUpperGroup.add(rightLegs);
            //humanUpperGroup.translateY(-0.2); when you will use the decreasing part of the upper body you will use this in the animation
            //humanUpperGroup.rotateZ(radians); //when the human will get the stick from the ground he will use this to lay down 

            torsoCylinder.rotateZ(Math.PI / 180 * 90);
            
            //humanGroup.position.z = 0;
            humanGroup.position.x = -2;

            humanGroup.add(humanUpperGroup);
           
            //humanGroup.scale.set(1,1,1.2);
            scene.add(humanGroup);

        }

     

       


        function createDoggo() {

            dogGroup = new THREE.Object3D;
             headGroup = new THREE.Object3D;
            dogLegFlag = true;

            const headGeometry = new THREE.SphereBufferGeometry(
                0.25, 20, 20);
            const sphereGeometry = new THREE.SphereBufferGeometry(
                0.25, 20, 40);

            const eyesGeometry = new THREE.SphereBufferGeometry(
                0.045, 50, 50);
            const eyesMaterial = new THREE.MeshBasicMaterial({ color: 0xdad9ff});

            const eye1 = new THREE.Mesh(eyesGeometry, eyesMaterial);
            const eye2 = new THREE.Mesh(eyesGeometry, eyesMaterial);

            const noseMaterial = new THREE.MeshBasicMaterial({ color: 0xda2c43 });
            const nose = new THREE.Mesh(eyesGeometry, noseMaterial);

            nose.position.set(0.63, 0.003,-4);
            eye1.position.set(0.7, 0.13, -3.85);
            eye2.position.set(0.7, 0.13, -4.25);


            var earGeometry = new THREE.BoxGeometry(0.08,0.3,0.4)
            var earMaterial = new THREE.MeshBasicMaterial({ color: 0x000000 });
            var ear1 = new THREE.Mesh(earGeometry, earMaterial);
            var ear2 = new THREE.Mesh(earGeometry, earMaterial);


            var neckCylinderGeometry = new THREE.CylinderGeometry(0.15, 0.15, 0.05, 0.05);
            var neckCylinderMaterial = new THREE.MeshBasicMaterial({ color: 0xffffff });

            var neckCylinder = new THREE.Mesh(neckCylinderGeometry, neckCylinderMaterial);

            var tailCylinderGeometry = new THREE.CylinderGeometry(0.23, .05, 0.05, 0.06);

        
            const sphereGeometryTorso = sphereGeometry.scale(2.5, 1, 1);

            const torsoMaterial = new THREE.MeshPhongMaterial({ emissive: 0xD2691E });
            const torsoMesh = new THREE.Mesh(sphereGeometryTorso, torsoMaterial);

            const headMesh = new THREE.Mesh(headGeometry, torsoMaterial);

            leftDogLeg = createArm();
            leftDogArm = createArm();

            rightDogLeg = createArm();
            rightDogArm = createArm();

            var tailMesh = new THREE.Mesh(tailCylinderGeometry, torsoMaterial);
            tailMesh.rotateZ(Math.PI / 7);

            torsoMesh.position.set(1.5, -0.4, -4);
            headMesh.position.set(0.87, 0.07, -4);
            neckCylinder.rotateZ(Math.PI / 7);
            neckCylinder.position.set(1, -0.2, -4);

            rightDogArm.position.set(1.2, -0.8, -3.85);
            leftDogArm.position.set(1.2, -0.8, -4.25);

            leftDogLeg.position.set(1.7, -0.8, -3.85);
            rightDogLeg.position.set(1.7,-0.8,-4.25 );

            tailMesh.position.set(2.2, -0.2, -4);
            ear1.position.set(0.94, 0.04, -3.85);
            ear2.position.set(0.94, 0.04, -4.25);
            headGroup.add(ear1);
            headGroup.add(ear2);
            headGroup.add(nose);

            headGroup.add(eye1);
            headGroup.add(eye2);
            //dogGroup.rotateZ(Math.PI); 
           // dogGroup.rotateZ(Math.PI);
            dogGroup.add(tailMesh);

            dogGroup.position.set(1.5,0,-4);
            headGroup.add(headMesh);
            headGroup.add(neckCylinder);
            dogGroup.add(leftDogArm);
            dogGroup.add(rightDogArm);
            dogGroup.add(leftDogLeg);
            dogGroup.add(rightDogLeg);
            dogGroup.add(torsoMesh);
            dogGroup.scale.set(1, 1, 1.2);
           // dogGroup.rotateY(Math.PI / 2);
            //dogGroup.rotateY(Math.PI/2) ;
            dogGroup.add(headGroup);
            scene.add(dogGroup);


        }
    </script>

</body>
</html>